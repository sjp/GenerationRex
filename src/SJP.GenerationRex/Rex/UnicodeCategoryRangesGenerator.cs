using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using EnumsNET;

namespace SJP.GenerationRex
{
    public static class UnicodeCategoryRangesGenerator
    {
        public static void Generate(string namespacename, string classname, string path)
        {
            if (classname == null)
                throw new ArgumentNullException(nameof(classname));
            if (path == null)
                throw new ArgumentNullException(nameof(path));
            if (path != "" && !path.EndsWith("/"))
                path += "/";
            string str1 = "//\r\n//Automatically generated by UnicodeCategoryRangesGenerator\r\n//\r\nnamespace " + namespacename + "\r\n{\r\npublic static class " + classname + "\r\n{";
            var fileName = path + classname + ".cs";
            var fileInfo = new FileInfo(fileName);
            if (fileInfo.Exists && fileInfo.IsReadOnly)
                fileInfo.IsReadOnly = false;
            using (var sw = File.AppendText(fileName))
            {
                sw.WriteLine(str1);
                sw.WriteLine("#region ASCII");
                WriteRangeFields(7, sw, "ASCII");
                sw.WriteLine("#endregion");
                sw.WriteLine();
                sw.WriteLine("#region CP437");
                WriteRangeFields(8, sw, "CP437");
                sw.WriteLine("#endregion");
                sw.WriteLine();
                sw.WriteLine("#region Unicode (UTF16)");
                WriteRangeFields(16, sw, "Unicode");
                sw.WriteLine("#endregion");
                sw.WriteLine();
                sw.WriteLine("}\r\n}\r\n");
            }
        }

        private static void WriteRangeFields(int bits, StreamWriter sw, string field)
        {
            var bitMaxValue = (1 << bits) - 1;
            var dictionary = new Dictionary<UnicodeCategory, Ranges>();
            foreach (var category in Enums.GetValues<UnicodeCategory>())
                dictionary[category] = new Ranges();

            var ranges = new Ranges();
            for (var n = 0; n <= bitMaxValue; n++)
            {
                var c = (char)n;
                if (char.IsWhiteSpace(c))
                    ranges.Add(n);
                UnicodeCategory unicodeCategory = char.GetUnicodeCategory(c);
                dictionary[unicodeCategory].Add(n);
            }
            var bddArray = new Dictionary<UnicodeCategory, BinaryDecisionDiagram>();
            var bddBuilder = new BddBuilder(bits);
            foreach (var category in Enums.GetValues<UnicodeCategory>())
                bddArray[category] = bddBuilder.MkBddForIntRanges(dictionary[category].ranges);
            BinaryDecisionDiagram bdd1 = bddBuilder.MkBddForIntRanges(ranges.ranges);
            BinaryDecisionDiagram bdd2 = bddBuilder.MkOr(
                bddArray[UnicodeCategory.UppercaseLetter],
                bddBuilder.MkOr(
                    bddArray[UnicodeCategory.LowercaseLetter],
                    bddBuilder.MkOr(
                        bddArray[UnicodeCategory.TitlecaseLetter],
                        bddBuilder.MkOr(
                            bddArray[UnicodeCategory.ModifierLetter],
                            bddBuilder.MkOr(
                                bddArray[UnicodeCategory.OtherLetter],
                                bddBuilder.MkOr(
                                    bddArray[UnicodeCategory.DecimalDigitNumber],
                                    bddArray[UnicodeCategory.ConnectorPunctuation]))))));
            sw.WriteLine("/// <summary>\r\n/// Compact BDD encodings of the categories.\r\n/// </summary>");
            sw.WriteLine("public static int[][] " + field + "Bdd = new int[][] {");
            foreach (UnicodeCategory key in dictionary.Keys)
            {
                sw.WriteLine("//{0}({1}):", key, key);
                BinaryDecisionDiagram bdd3 = bddArray[key];
                if (bdd3 == null || bdd3 == BinaryDecisionDiagram.False)
                {
                    sw.WriteLine("null, //false");
                }
                else if (bdd3 == BinaryDecisionDiagram.True)
                {
                    sw.WriteLine("new int[] { 0, 0 }, //true");
                }
                else
                {
                    sw.WriteLine("new int[] {");
                    foreach (int num2 in bddBuilder.SerializeCompact(bdd3))
                        sw.WriteLine("{0},", num2);
                    sw.WriteLine("},");
                }
            }
            sw.WriteLine("};");
            sw.WriteLine("/// <summary>\r\n/// Compact BDD encoding of the whitespace characters.\r\n/// </summary>");
            sw.WriteLine("public static int[] " + field + "WhitespaceBdd = new int[]{");
            foreach (int num2 in bddBuilder.SerializeCompact(bdd1))
                sw.WriteLine("{0},", num2);
            sw.WriteLine("};");
            sw.WriteLine("/// <summary>\r\n/// Compact BDD encoding of word characters is the BDD for the union of categories UppercaseLetter, LowercaseLetter, TitlecaseLetter, ModifierLetter, OtherLetter, DecimalDigitNumber, ConnectorPunctuation\r\n/// </summary>");
            sw.WriteLine("public static int[] " + field + "WordCharacterBdd = new int[]{");
            foreach (int num2 in bddBuilder.SerializeCompact(bdd2))
                sw.WriteLine("{0},", num2);
            sw.WriteLine("};");
        }

        private class Ranges
        {
            internal List<int[]> ranges = new List<int[]>();

            internal void Add(int n)
            {
                for (int index = 0; index < ranges.Count; ++index)
                {
                    if (ranges[index][1] == n - 1)
                    {
                        ranges[index][1] = n;
                        return;
                    }
                }
                ranges.Add(new int[2] { n, n });
            }

            internal int Count => ranges.Count;
        }
    }
}
